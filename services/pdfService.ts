import { PDFDocument, rgb, PDFFont, PDFPage, PDFImage, StandardFonts } from 'pdf-lib';
import html2canvas from 'html2canvas';
import { ReportTemplate, StructuralCalculationPayload, GeotechnicalCalculationPayload, Verification, CalculationStep, DocumentPayload, JobSafetyAnalysis } from '../types';

export interface PrintableContent {
    title: string;
    mainText: string;
    tableData: { headers: string[], rows: (string | null)[][] } | null;
    imageB64: string | null;
    calculationPayload?: StructuralCalculationPayload | GeotechnicalCalculationPayload;
}

const FONT_SIZES = { h1: 18, h2: 14, h3: 12, p: 10, table: 9, footer: 8, mono: 9 };
const LINE_HEIGHT_MULTIPLIER = 1.4;

interface Margins {
    top: number;
    bottom: number;
    left: number;
    right: number;
}

// --- START: SMART FONT SWITCHING LOGIC ---

const SYMBOL_CHARS = new Set(['α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Γ', 'Δ', 'Θ', 'Λ', 'Ξ', 'Π', 'Σ', 'Φ', 'Ψ', 'Ω', '≥', '≤', '≠', '≈', '√', '±', '°']);

function isSymbol(char: string): boolean {
    return SYMBOL_CHARS.has(char);
}

function calculateSmartTextWidth(
    text: string,
    font: PDFFont,
    symbolFont: PDFFont,
    fontSize: number
): number {
    let totalWidth = 0;
    if (!text) return 0;

    let segment = '';
    let isLastSegmentSymbol = isSymbol(text[0]);

    for (const char of text) {
        const isCurrentCharSymbol = isSymbol(char);
        if (isCurrentCharSymbol !== isLastSegmentSymbol) {
            const currentFont = isLastSegmentSymbol ? symbolFont : font;
            totalWidth += currentFont.widthOfTextAtSize(segment, fontSize);
            segment = char;
            isLastSegmentSymbol = isCurrentCharSymbol;
        } else {
            segment += char;
        }
    }
    if (segment) {
        const finalFont = isLastSegmentSymbol ? symbolFont : font;
        totalWidth += finalFont.widthOfTextAtSize(segment, fontSize);
    }
    return totalWidth;
}


const drawSmartText = (
    page: PDFPage,
    text: string,
    x: number,
    y: number,
    font: PDFFont,
    symbolFont: PDFFont,
    size: number,
    color = rgb(0.15, 0.15, 0.18) // Default to near-black for better readability on white
) => {
    let currentX = x;
    if (!text) return;
    
    let segment = '';
    let isLastSegmentSymbol = isSymbol(text[0]);

    for (const char of text) {
        const isCurrentCharSymbol = isSymbol(char);
        if (isCurrentCharSymbol !== isLastSegmentSymbol) {
            const currentFont = isLastSegmentSymbol ? symbolFont : font;
            page.drawText(segment, { x: currentX, y, font: currentFont, size, color });
            currentX += currentFont.widthOfTextAtSize(segment, size);
            segment = char;
            isLastSegmentSymbol = isCurrentCharSymbol;
        } else {
            segment += char;
        }
    }
    if (segment) {
        const finalFont = isLastSegmentSymbol ? symbolFont : font;
        page.drawText(segment, { x: currentX, y, font: finalFont, size, color });
    }
};

// --- END: SMART FONT SWITCHING LOGIC ---


interface DrawContext {
    doc: PDFDocument;
    page: PDFPage;
    y: number;
    font: PDFFont;
    fontBold: PDFFont;
    fontMono: PDFFont;
    symbolFont: PDFFont;
    width: number;
    height: number;
    margins: Margins;
    template: ReportTemplate;
    headerImage?: PDFImage;
    footerImage?: PDFImage;
    headerHeight: number;
    footerHeight: number;
}

const drawBrandingAndFooter = (ctx: DrawContext, pageNum: number, totalPages: number): void => {
    if (ctx.headerImage) {
        const imageDims = ctx.headerImage.scaleToFit(ctx.width, ctx.headerHeight);
        ctx.page.drawImage(ctx.headerImage, {
            x: (ctx.width - imageDims.width) / 2,
            y: ctx.height - imageDims.height,
            width: imageDims.width,
            height: imageDims.height
        });
    }

    if (ctx.footerImage) {
        const imageDims = ctx.footerImage.scaleToFit(ctx.width, ctx.footerHeight);
        ctx.page.drawImage(ctx.footerImage, {
            x: (ctx.width - imageDims.width) / 2,
            y: 0,
            width: imageDims.width,
            height: imageDims.height
        });
    }

    if (!ctx.template.isBranded) {
        const footerText = `Generated by FLOCORE AI`;
        const pageNumText = `Page ${pageNum} of ${totalPages}`;
        
        drawSmartText(ctx.page, footerText, ctx.margins.left, ctx.margins.bottom / 2, ctx.font, ctx.symbolFont, FONT_SIZES.footer, rgb(0.5, 0.5, 0.5));
        drawSmartText(ctx.page, pageNumText, ctx.width - ctx.margins.right - calculateSmartTextWidth(pageNumText, ctx.font, ctx.symbolFont, FONT_SIZES.footer), ctx.margins.bottom / 2, ctx.font, ctx.symbolFont, FONT_SIZES.footer, rgb(0.5, 0.5, 0.5));
    }
};


const addNewPage = (ctx: DrawContext): PDFPage => {
    const newPage = ctx.doc.addPage();
    ctx.page = newPage;
    ctx.y = ctx.height - ctx.margins.top;
    return newPage;
};

const checkAndMoveToNextPage = (ctx: DrawContext, requiredHeight: number): void => {
    if (ctx.y - requiredHeight < ctx.margins.bottom) {
        addNewPage(ctx);
    }
};

function getTextLines(
    text: string,
    font: PDFFont,
    symbolFont: PDFFont,
    fontSize: number,
    maxWidth: number
): string[] {
    const lines: string[] = [];
    if (!text) return lines;
    const paragraphs = text.split('\n');
    for (const paragraph of paragraphs) {
        const words = paragraph.split(' ');
        let currentLine = '';
        for (const word of words) {
            const testLine = currentLine.length > 0 ? `${currentLine} ${word}` : word;
            const width = calculateSmartTextWidth(testLine, font, symbolFont, fontSize);
            if (width < maxWidth) {
                currentLine = testLine;
            } else {
                lines.push(currentLine.trim());
                currentLine = word;
            }
        }
        lines.push(currentLine.trim());
    }
    return lines;
}

const drawWrappedText = (ctx: DrawContext, text: string, fontSize: number, font: PDFFont, color = rgb(0.15, 0.15, 0.18)): void => {
    const maxWidth = ctx.width - ctx.margins.left - ctx.margins.right;
    const lines = getTextLines(text, font, ctx.symbolFont, fontSize, maxWidth);
    const lineHeight = fontSize * LINE_HEIGHT_MULTIPLIER;

    for (const line of lines) {
        checkAndMoveToNextPage(ctx, lineHeight);
        drawSmartText(ctx.page, line, ctx.margins.left, ctx.y, font, ctx.symbolFont, fontSize, color);
        ctx.y -= lineHeight;
    }
};

const renderStepCardToPng = async (step: CalculationStep, index: number): Promise<{ pngB64: string, width: number, height: number }> => {
    const derivationHtml = step.derivationSteps.map(line => {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith('$$') && trimmedLine.endsWith('$$')) {
            return `<div style="font-size: ${FONT_SIZES.p}pt; padding-left: 20px; line-height: 1.5;">${trimmedLine}</div>`;
        }
        return `<p style="font-size: ${FONT_SIZES.p}pt; padding-left: 20px; color: #3f3f46; margin: 4px 0;">${line}</p>`; // zinc-700
    }).join('');

    // Light theme styles for PDF
    const htmlContent = `
        <div style="font-family: 'Plus Jakarta Sans', sans-serif; background-color: #f4f4f5; border-radius: 8px; padding: 16px; width: 850px; display: inline-block;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                <h5 style="font-weight: 600; color: #18181b; font-size: 13px; margin: 0;">${index + 1}. ${step.title}</h5>
                <span style="font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #52525b; background-color: #e4e4e7; padding: 2px 8px; border-radius: 4px; flex-shrink: 0; margin-left: 16px;">
                    ${'standardReference' in step ? step.standardReference : (step as any).theoryReference}
                </span>
            </div>
            ${derivationHtml}
        </div>
    `;
    
    const container = document.createElement('div');
    document.body.appendChild(container);
    Object.assign(container.style, {
        position: 'absolute',
        left: '-9999px',
        top: '0px',
        // Sandboxing styles for correct MathJax rendering
        backgroundColor: 'white',
        color: 'black'
    });
    container.innerHTML = htmlContent;
    
    try {
        // @ts-ignore
        await window.MathJax.startup.promise;
        // @ts-ignore
        await window.MathJax.typesetPromise([container]);
        
        // FIX: Add a small delay to ensure the browser has fully painted the MathJax output
        // before html2canvas captures it. This prevents a race condition where formulas
        // might be captured before they are completely rendered, causing them to appear cut off.
        await new Promise(resolve => setTimeout(resolve, 200));
        
        const canvas = await html2canvas(container.firstElementChild as HTMLElement, {
            backgroundColor: null, // Transparent background for the card itself
            scale: 2 // Render at 2x resolution for high quality
        });
        
        const pngB64 = canvas.toDataURL('image/png');
        return { pngB64, width: canvas.width / 2, height: canvas.height / 2 };
    } catch (e) {
        console.error("Failed to render Step Card to PNG:", e);
        return { pngB64: '', width: 0, height: 0 };
    } finally {
        document.body.removeChild(container);
    }
}

const renderVerificationToPng = async (verification: Verification): Promise<{ pngB64: string, width: number, height: number }> => {
    const statusClasses = {
        OK: { text: '#16a34a', border: '#22c55e' }, // green-600, green-500
        FAIL: { text: '#dc2626', border: '#ef4444' }, // red-600, red-500
        WARNING: { text: '#d97706', border: '#f59e0b' }, // amber-600, amber-500
    };
    const colors = statusClasses[verification.status];
    
    const svgIcons = {
        OK: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="${colors.text}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m9 12 2 2 4-4"/></svg>`,
        FAIL: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="${colors.text}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>`,
        WARNING: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="${colors.text}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>`
    };

    const htmlContent = `
        <div style="font-family: 'Plus Jakarta Sans', sans-serif; background-color: transparent; border-left: 4px solid ${colors.border}; padding: 12px 16px; width: 850px; display: inline-block; font-size: ${FONT_SIZES.p}pt; line-height: 1.5;">
            <div style="display: flex; align-items: flex-start; gap: 12px;">
                <div style="flex-shrink: 0; margin-top: 2px;">${svgIcons[verification.status]}</div>
                <div style="flex-grow: 1;">
                    <p style="font-weight: 600; margin: 0 0 8px 0; color: #18181b;">${verification.checkName}</p>
                    <div style="font-family: 'JetBrains Mono', monospace; font-size: ${FONT_SIZES.mono}pt; color: #3f3f46;">${verification.evaluation}</div>
                </div>
            </div>
        </div>
    `;

    const container = document.createElement('div');
    document.body.appendChild(container);
    Object.assign(container.style, {
        position: 'absolute',
        left: '-9999px',
        top: '0px',
        // Sandboxing styles for correct MathJax rendering
        backgroundColor: 'white',
        color: 'black'
    });
    container.innerHTML = htmlContent;

    try {
        // @ts-ignore
        await window.MathJax.startup.promise;
        // @ts-ignore
        await window.MathJax.typesetPromise([container]);

        // FIX: Add a small delay to ensure the browser has fully painted the MathJax output
        // before html2canvas captures it. This prevents a race condition where formulas
        // might be captured before they are completely rendered, causing them to appear cut off.
        await new Promise(resolve => setTimeout(resolve, 200));

        const canvas = await html2canvas(container.firstElementChild as HTMLElement, {
            backgroundColor: null,
            scale: 2
        });

        const pngB64 = canvas.toDataURL('image/png');
        return { pngB64, width: canvas.width / 2, height: canvas.height / 2 };
    } catch(e) {
        console.error("Failed to render Verification to PNG:", e);
        return { pngB64: '', width: 0, height: 0 };
    } finally {
        document.body.removeChild(container);
    }
}


const drawTable = async (
    ctx: DrawContext,
    headers: string[],
    data: (string | null)[][]
): Promise<void> => {
    if (data.length === 0) return;

    const tableWidth = ctx.width - ctx.margins.left - ctx.margins.right;
    const fontSize = FONT_SIZES.table;
    const font = ctx.font;

    const colCount = headers.length;
    const colWidth = tableWidth / colCount;

    const textMargin = 5;
    const headerColor = rgb(0.9, 0.9, 0.9);
    const rowColorEven = rgb(1, 1, 1);
    const rowColorOdd = rgb(0.95, 0.95, 0.95);

    const drawRow = (rowData: (string | null)[], isHeader: boolean) => {
        const rowLineSets = rowData.map((cell) =>
            getTextLines(cell || '', isHeader ? ctx.fontBold : font, ctx.symbolFont, fontSize, colWidth - textMargin * 2)
        );

        const maxLines = Math.max(1, ...rowLineSets.map(lines => lines.length));
        const rowHeight = maxLines * (fontSize * 1.2) + textMargin * 2;

        checkAndMoveToNextPage(ctx, rowHeight);
        
        ctx.page.drawRectangle({
            x: ctx.margins.left,
            y: ctx.y - rowHeight,
            width: tableWidth,
            height: rowHeight,
            color: isHeader ? headerColor : (data.indexOf(rowData) % 2 === 0 ? rowColorEven : rowColorOdd),
        });

        rowData.forEach((_, i) => {
            const lines = rowLineSets[i];
            lines.forEach((line, lineIndex) => {
                const textY = ctx.y - textMargin - (fontSize * 1.2 * (lineIndex + 0.8));
                drawSmartText(ctx.page, line, ctx.margins.left + i * colWidth + textMargin, textY, isHeader ? ctx.fontBold : font, ctx.symbolFont, fontSize, rgb(0.1, 0.1, 0.1));
            });
        });
        
        ctx.y -= rowHeight;
    };

    drawRow(headers, true);
    data.forEach((row) => drawRow(row, false));
};

const drawCalculationCard = async (ctx: DrawContext, payload: StructuralCalculationPayload | GeotechnicalCalculationPayload) => {
    const { result } = payload;

    checkAndMoveToNextPage(ctx, 40);
    drawSmartText(ctx.page, payload.task, ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h1);
    ctx.y -= FONT_SIZES.h1 * LINE_HEIGHT_MULTIPLIER;
    ctx.page.drawLine({
        start: { x: ctx.margins.left, y: ctx.y },
        end: { x: ctx.width - ctx.margins.right, y: ctx.y },
        thickness: 0.5,
        color: rgb(0.8, 0.8, 0.8),
    });
    ctx.y -= 20;

    checkAndMoveToNextPage(ctx, 30);
    drawSmartText(ctx.page, "Problem Statement", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
    ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
    drawWrappedText(ctx, `"${result.problemStatement}"`, FONT_SIZES.p, ctx.font, rgb(0.3, 0.3, 0.3));
    ctx.y -= 20;

    if (result.givenData && result.givenData.length > 0) {
        checkAndMoveToNextPage(ctx, 30);
        drawSmartText(ctx.page, "Given Data", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
        ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
        result.givenData.forEach(item => {
            drawWrappedText(ctx, `• ${item}`, FONT_SIZES.p, ctx.font);
        });
        ctx.y -= 10;
    }

    if (result.assumptions && result.assumptions.length > 0) {
        checkAndMoveToNextPage(ctx, 30);
        drawSmartText(ctx.page, "Assumptions", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
        ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
        result.assumptions.forEach(item => {
            drawWrappedText(ctx, `• ${item}`, FONT_SIZES.p, ctx.font);
        });
        ctx.y -= 10;
    }

    checkAndMoveToNextPage(ctx, 30);
    drawSmartText(ctx.page, "Calculation Steps", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
    ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;

    for (const [index, step] of result.calculationSteps.entries()) {
        const { pngB64, width, height } = await renderStepCardToPng(step, index);
        if (pngB64) {
            const image = await ctx.doc.embedPng(pngB64);
            const availableWidth = ctx.width - ctx.margins.left - ctx.margins.right;
            const scaledDims = image.scaleToFit(availableWidth, height);
            
            checkAndMoveToNextPage(ctx, scaledDims.height + 5);
            ctx.page.drawImage(image, {
                x: ctx.margins.left,
                y: ctx.y - scaledDims.height,
                width: scaledDims.width,
                height: scaledDims.height,
            });
            ctx.y -= scaledDims.height + 5;
        }
    }
    
    if (result.verifications && result.verifications.length > 0) {
        ctx.y -= 10;
        checkAndMoveToNextPage(ctx, 30);
        drawSmartText(ctx.page, "Verifications", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
        ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
        for (const verification of result.verifications) {
             const { pngB64, width, height } = await renderVerificationToPng(verification);

            if (pngB64) {
                const image = await ctx.doc.embedPng(pngB64);
                const availableWidth = ctx.width - ctx.margins.left - ctx.margins.right;
                const scaledDims = image.scaleToFit(availableWidth, height);

                checkAndMoveToNextPage(ctx, scaledDims.height + 10);
                ctx.page.drawImage(image, {
                    x: ctx.margins.left,
                    y: ctx.y - scaledDims.height,
                    width: scaledDims.width,
                    height: scaledDims.height,
                });
                ctx.y -= scaledDims.height + 10;
            }
        }
    }

    let recs = result.recommendations;
    if ('warnings' in result && (result as any).warnings) {
        recs = [...(recs || []), ...((result as any).warnings || [])];
    }
    
    if (recs && recs.length > 0) {
        ctx.y -= 10;
        checkAndMoveToNextPage(ctx, 30);
        drawSmartText(ctx.page, "Recommendations & Warnings", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
        ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
        const text = recs.map(r => `• ${r}`).join('\n');
        drawWrappedText(ctx, text, FONT_SIZES.p, ctx.font, rgb(0.7, 0.5, 0.1));
        ctx.y -= 20;
    }

    ctx.y -= 10;
    checkAndMoveToNextPage(ctx, 30);
    drawSmartText(ctx.page, "Conclusion", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3);
    ctx.y -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;

    drawWrappedText(ctx, result.conclusion.summary, FONT_SIZES.p, ctx.font);
    ctx.y -= FONT_SIZES.p * 1.5;

    const finalAnswerText = `${result.conclusion.finalAnswer.name}: ${result.conclusion.finalAnswer.value} ${result.conclusion.finalAnswer.unit}`;
    const textPadding = { x: 10, y: 10 };
    const contentWidth = ctx.width - ctx.margins.left - ctx.margins.right;
    const lines = getTextLines(finalAnswerText, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3, contentWidth - textPadding.x * 2);
    const textHeight = lines.length * (FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER);
    const answerBoxHeight = textHeight + textPadding.y * 2;

    checkAndMoveToNextPage(ctx, answerBoxHeight + 10);
    ctx.page.drawRectangle({
        x: ctx.margins.left, y: ctx.y - answerBoxHeight,
        width: contentWidth, height: answerBoxHeight,
        color: rgb(0.85, 0.9, 1),
        borderColor: rgb(0.23, 0.51, 0.96),
        borderWidth: 1.5
    });
    
    let textY = ctx.y - textPadding.y - FONT_SIZES.h3; // Start position for first line
    for (const line of lines) {
        drawSmartText(ctx.page, line, ctx.margins.left + textPadding.x, textY, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h3, rgb(0.1, 0.2, 0.4));
        textY -= FONT_SIZES.h3 * LINE_HEIGHT_MULTIPLIER;
    }
    ctx.y -= answerBoxHeight + 10;
};

export const generateReportPdf = async (
    content: PrintableContent,
    template: ReportTemplate
): Promise<Uint8Array> => {
    const pdfDoc = await PDFDocument.create();
    pdfDoc.setProducer('FLOCORE AI');
    pdfDoc.setCreator('FLOCORE AI');
    pdfDoc.setTitle(content.title);

    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const fontMono = await pdfDoc.embedFont(StandardFonts.Courier);
    const symbolFont = await pdfDoc.embedFont(StandardFonts.Symbol);
    
    let page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    
    const ctx: DrawContext = {
        doc: pdfDoc,
        page,
        y: 0,
        font,
        fontBold,
        fontMono,
        symbolFont,
        width,
        height,
        margins: { top: 60, bottom: 60, left: 50, right: 50 },
        template,
        headerHeight: 0,
        footerHeight: 0,
    };
    
    if (template.isBranded) {
        if (template.headerImage) {
            const imageBytes = Uint8Array.from(atob(template.headerImage.split(',')[1]), c => c.charCodeAt(0));
            try {
                ctx.headerImage = await pdfDoc.embedPng(imageBytes);
            } catch {
                ctx.headerImage = await pdfDoc.embedJpg(imageBytes);
            }
            ctx.headerHeight = Math.min(height * 0.15, ctx.headerImage.height * (width / ctx.headerImage.width));
            ctx.margins.top = ctx.headerHeight + 20; 
        }
        if (template.footerImage) {
            const imageBytes = Uint8Array.from(atob(template.footerImage.split(',')[1]), c => c.charCodeAt(0));
            try {
                ctx.footerImage = await pdfDoc.embedPng(imageBytes);
            } catch {
                 ctx.footerImage = await pdfDoc.embedJpg(imageBytes);
            }
            ctx.footerHeight = Math.min(height * 0.10, ctx.footerImage.height * (width / ctx.footerImage.width));
            ctx.margins.bottom = ctx.footerHeight + 20;
        }
    }
    
    ctx.y = height - ctx.margins.top;

    if (!template.isBranded) {
        drawSmartText(page, "FLOCORE AI", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h1, rgb(0.23, 0.51, 0.96));
        const dateText = `Date: ${new Date().toLocaleDateString()}`;
        const templateText = `${template.name} Report`;
        
        const templateWidth = calculateSmartTextWidth(templateText, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h2);
        drawSmartText(page, templateText, ctx.width - ctx.margins.right - templateWidth, ctx.y + 5, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h2);
        
        const dateWidth = calculateSmartTextWidth(dateText, ctx.font, ctx.symbolFont, FONT_SIZES.p);
        drawSmartText(page, dateText, ctx.width - ctx.margins.right - dateWidth, ctx.y - 10, ctx.font, ctx.symbolFont, FONT_SIZES.p);
        
        ctx.y -= 40;
        ctx.page.drawLine({
            start: { x: ctx.margins.left, y: ctx.y },
            end: { x: ctx.width - ctx.margins.right, y: ctx.y },
            thickness: 1,
            color: rgb(0.9, 0.9, 0.9),
        });
        ctx.y -= 30;
    }

    if (content.imageB64) {
        try {
            const imageBytes = Uint8Array.from(atob(content.imageB64), c => c.charCodeAt(0));
            let image;
            try { image = await pdfDoc.embedPng(imageBytes); } catch { image = await pdfDoc.embedJpg(imageBytes); }
            
            const availableWidth = ctx.width - ctx.margins.left - ctx.margins.right;
            const imageDims = image.scaleToFit(availableWidth, 300);

            checkAndMoveToNextPage(ctx, imageDims.height + 20);
            ctx.page.drawImage(image, {
                x: (ctx.width - imageDims.width) / 2,
                y: ctx.y - imageDims.height,
                ...imageDims,
            });
            ctx.y -= (imageDims.height + 20);
        } catch(e) { console.error("Failed to embed image:", e); }
    }
    
    if (content.calculationPayload) {
        await drawCalculationCard(ctx, content.calculationPayload);
    } else {
        checkAndMoveToNextPage(ctx, FONT_SIZES.h2 + 25);
        drawSmartText(ctx.page, content.title, ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h2);
        ctx.y -= (FONT_SIZES.h2 * LINE_HEIGHT_MULTIPLIER + 10);
        
        drawWrappedText(ctx, content.mainText, FONT_SIZES.p, ctx.font);
        ctx.y -= 20;

        if (content.tableData && content.tableData.rows.length > 0) {
            checkAndMoveToNextPage(ctx, FONT_SIZES.h2 + 25);
            drawSmartText(ctx.page, "Details", ctx.margins.left, ctx.y, ctx.fontBold, ctx.symbolFont, FONT_SIZES.h2);
            ctx.y -= (FONT_SIZES.h2 * LINE_HEIGHT_MULTIPLIER + 10);
            await drawTable(ctx, content.tableData.headers, content.tableData.rows);
        }
    }
    
    const pageCount = pdfDoc.getPageCount();
    pdfDoc.getPages().forEach((p, i) => {
        ctx.page = p;
        drawBrandingAndFooter(ctx, i + 1, pageCount);
    });

    return pdfDoc.save();
};